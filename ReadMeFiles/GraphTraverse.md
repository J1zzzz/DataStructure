
---

# 广度优先遍历（BFS）无向图的C语言实现

## 项目简介
这是一个使用C语言实现无向图的广度优先遍历（BFS）的项目。图采用邻接表存储结构，通过队列实现BFS算法。

## 图的结构
### 邻接表表示
- **Graph结构**：
  - `numVertices`：顶点数量。
  - `adjLists`：邻接表数组，每个元素是一个指向`Node`的指针，表示与该顶点相邻的顶点链表。
- **Node结构**：
  - `vertex`：顶点编号。
  - `next`：指向下一个邻接点的指针。

### 队列结构
- **Queue结构**：
  - `front`：队列前端索引。
  - `rear`：队列后端索引。
  - `size`：队列当前大小。
  - `capacity`：队列最大容量。
  - `array`：存储队列元素的数组。

## 图的示例
假设我们有一个包含6个顶点的无向图，顶点编号为0到5，边的连接如下：
- 0 - 1
- 0 - 2
- 1 - 2
- 1 - 4
- 2 - 3
- 3 - 4
- 4 - 5

### 邻接表表示
- `adjLists[0]`：1 -> 2 -> NULL
- `adjLists[1]`：0 -> 2 -> 4 -> NULL
- `adjLists[2]`：0 -> 1 -> 3 -> NULL
- `adjLists[3]`：2 -> 4 -> NULL
- `adjLists[4]`：1 -> 3 -> 5 -> NULL
- `adjLists[5]`：4 -> NULL

### 图的示意图
```
    0
   / \
  1---2
   \ / \
    4---3
     \
      5
```

## 广度优先遍历（BFS）
从顶点0开始进行BFS遍历，遍历顺序如下：
1. 访问顶点0，将其加入队列。
2. 从队列中取出顶点0，访问其邻接点1和2，将它们加入队列。
3. 从队列中取出顶点1，访问其邻接点2和4，将它们加入队列（如果未访问）。
4. 从队列中取出顶点2，访问其邻接点3，将其加入队列。
5. 从队列中取出顶点4，访问其邻接点5，将其加入队列。
6. 从队列中取出顶点3和5，没有新的邻接点加入队列。

最终的BFS遍历顺序为：0 -> 1 -> 2 -> 4 -> 3 -> 5。

## 示例输出
对于上述图，从顶点0开始进行BFS遍历，输出结果如下：
```
BFS starting from vertex 0: 0 1 2 4 3 5
```

## 编译与运行
1. 将代码保存为`bfs_graph.c`。
2. 使用C编译器（如gcc）编译代码：
   ```bash
   gcc bfs_graph.c -o bfs_graph
   ```
3. 运行生成的可执行文件：
   ```bash
   ./bfs_graph
   ```

## 注意事项
- 确保图的顶点编号从0开始，且连续。
- 在实际应用中，可以根据需要调整图的大小和边的连接关系。

---

---

# 深度优先遍历（DFS）无向图的C语言实现

## 项目简介
这是一个使用C语言实现无向图的深度优先遍历（DFS）的项目。图采用邻接表存储结构，通过递归函数实现DFS算法。

## 图的结构
### 邻接表表示
- **Graph结构**：
  - `numVertices`：顶点数量。
  - `adjLists`：邻接表数组，每个元素是一个指向`Node`的指针，表示与该顶点相邻的顶点链表。
- **Node结构**：
  - `vertex`：顶点编号。
  - `next`：指向下一个邻接点的指针。

## 图的示例
假设我们有一个包含6个顶点的无向图，顶点编号为0到5，边的连接如下：
- 0 - 1
- 0 - 2
- 1 - 2
- 1 - 4
- 2 - 3
- 3 - 4
- 4 - 5

### 邻接表表示
- `adjLists[0]`：1 -> 2 -> NULL
- `adjLists[1]`：0 -> 2 -> 4 -> NULL
- `adjLists[2]`：0 -> 1 -> 3 -> NULL
- `adjLists[3]`：2 -> 4 -> NULL
- `adjLists[4]`：1 -> 3 -> 5 -> NULL
- `adjLists[5]`：4 -> NULL

### 图的示意图
```
    0
   / \
  1---2
   \ / \
    4---3
     \
      5
```

## 深度优先遍历（DFS）
从顶点1开始进行DFS遍历，遍历顺序如下：
1. 访问顶点1，将其标记为已访问。
2. 访问顶点1的邻接点2，将其标记为已访问。
3. 访问顶点2的邻接点3，将其标记为已访问。
4. 访问顶点3的邻接点4，将其标记为已访问。
5. 访问顶点4的邻接点5，将其标记为已访问。
6. 回溯到顶点4，访问顶点4的邻接点1（已访问），不再继续。
7. 回溯到顶点3，访问顶点3的邻接点2（已访问），不再继续。
8. 回溯到顶点2，访问顶点2的邻接点0，将其标记为已访问。
9. 回溯到顶点1，访问顶点1的邻接点4（已访问），不再继续。

最终的DFS遍历顺序为：1 -> 2 -> 3 -> 4 -> 5 -> 0。

## 示例输出
对于上述图，从顶点1开始进行DFS遍历，输出结果如下：
```
DFS starting from vertex 1: 1 2 3 4 5 0
```

## 编译与运行
1. 将代码保存为`dfs_graph.c`。
2. 使用C编译器（如gcc）编译代码：
   ```bash
   gcc dfs_graph.c -o dfs_graph
   ```
3. 运行生成的可执行文件：
   ```bash
   ./dfs_graph
   ```

## 注意事项
- 确保图的顶点编号从0开始，且连续。
- 在实际应用中，可以根据需要调整图的大小和边的连接关系。
- DFS的遍历顺序可能因邻接点的访问顺序不同而有所不同。

---

好的，以下是为你的深度优先遍历（DFS）和广度优先遍历（BFS）项目生成的`README.md`文档，其中包含了图的结构、示意图以及代码的说明。

---

# 邻接矩阵存储的深度优先遍历（DFS）和广度优先遍历（BFS）无向图的C语言实现

## 项目简介

## 图的结构
### 邻接矩阵表示
- **Graph结构**：
  - `numVertices`：顶点数量。
  - `adjMatrix`：邻接矩阵，`adjMatrix[i][j]`为1表示顶点`i`和顶点`j`之间有边，为0表示没有边。

### 队列结构（用于BFS）
- **Queue结构**：
  - `front`：队列前端索引。
  - `rear`：队列后端索引。
  - `size`：队列当前大小。
  - `capacity`：队列最大容量。
  - `array`：存储队列元素的数组。

## 图的示例
假设我们有一个包含6个顶点的无向图，顶点编号为0到5，边的连接如下：
- 0 - 1
- 0 - 2
- 1 - 2
- 1 - 4
- 2 - 3
- 3 - 4
- 4 - 5

### 邻接矩阵表示
```
    0 1 2 3 4 5
  0 0 1 1 0 0 0
  1 1 0 1 0 1 0
  2 1 1 0 1 0 0
  3 0 0 1 0 1 0
  4 0 1 0 1 0 1
  5 0 0 0 0 1 0
```

### 图的示意图
```
    0
   / \
  1---2
   \ / \
    4---3
     \
      5
```

## 深度优先遍历（DFS）
从顶点0开始进行DFS遍历，遍历顺序如下：
1. 访问顶点0，将其标记为已访问。
2. 访问顶点0的邻接点1，将其标记为已访问。
3. 访问顶点1的邻接点2，将其标记为已访问。
4. 访问顶点2的邻接点3，将其标记为已访问。
5. 访问顶点3的邻接点4，将其标记为已访问。
6. 访问顶点4的邻接点5，将其标记为已访问。
7. 回溯到顶点4，访问顶点4的邻接点1（已访问），不再继续。
8. 回溯到顶点3，访问顶点3的邻接点2（已访问），不再继续。
9. 回溯到顶点2，访问顶点2的邻接点0（已访问），不再继续。
10. 回溯到顶点1，访问顶点1的邻接点4（已访问），不再继续。

最终的DFS遍历顺序为：0 -> 1 -> 2 -> 3 -> 4 -> 5。

## 广度优先遍历（BFS）
从顶点0开始进行BFS遍历，遍历顺序如下：
1. 访问顶点0，将其加入队列。
2. 从队列中取出顶点0，访问其邻接点1和2，将它们加入队列。
3. 从队列中取出顶点1，访问其邻接点2和4，将它们加入队列（如果未访问）。
4. 从队列中取出顶点2，访问其邻接点3，将其加入队列。
5. 从队列中取出顶点4，访问其邻接点5，将其加入队列。
6. 从队列中取出顶点3和5，没有新的邻接点加入队列。

最终的BFS遍历顺序为：0 -> 1 -> 2 -> 4 -> 3 -> 5。

## 示例输出
对于上述图，从顶点0开始进行DFS和BFS遍历，输出结果如下：
```
DFS starting from vertex 0: 0 1 2 3 4 5
BFS starting from vertex 0: 0 1 2 4 3 5
```

## 编译与运行
1. 将代码保存为`dfs_bfs_graph.c`。
2. 使用C编译器（如gcc）编译代码：
   ```bash
   gcc dfs_bfs_graph.c -o dfs_bfs_graph
   ```
3. 运行生成的可执行文件：
   ```bash
   ./dfs_bfs_graph
   ```

## 注意事项
- 确保图的顶点编号从0开始，且连续。
- 在实际应用中，可以根据需要调整图的大小和边的连接关系。
- DFS和BFS的遍历顺序可能因邻接点的访问顺序不同而有所不同。

---


