
# 二路归并排序C语言实现

## 一、代码功能说明
本代码实现了二路归并排序算法，通过递归分治的思想将数组逐步拆分为子数组排序后合并，最终得到有序数组。适用于理解归并排序的基本原理和C语言实现方式。


## 二、代码结构说明
### 1. 核心函数
| 函数名       | 功能描述                                                                 |
|--------------|--------------------------------------------------------------------------|
| `merge`      | 合并两个已排序的子数组为一个有序数组                                     |
| `mergeSort`  | 递归实现归并排序，将数组拆分为左右两部分分别排序后合并                   |
| `printArray` | 打印数组元素，用于调试和结果展示                                         |

### 2. 关键步骤
1. **拆分数组**：通过递归将数组从中间拆分为左右两部分，直到子数组长度为1（天然有序）。
2. **合并数组**：将两个已排序的子数组合并为一个有序数组，使用临时空间存储中间结果，避免原地修改带来的复杂度。


## 三、代码实现细节
### 1. 合并函数 `merge`
```c
void merge(int arr[], int left, int mid, int right) {
    // 计算子数组长度
    int n1 = mid - left + 1;
    int n2 = right - mid;
    
    // 创建临时数组存储左右子数组
    int *L = (int *)malloc(n1 * sizeof(int));
    int *R = (int *)malloc(n2 * sizeof(int));
    
    // 复制数据到临时数组
    for (int i = 0; i < n1; i++) L[i] = arr[left + i];
    for (int j = 0; j < n2; j++) R[j] = arr[mid + 1 + j];
    
    // 合并临时数组到原数组
    int i = 0, j = 0, k = left;
    while (i < n1 && j < n2) {
        arr[k++] = (L[i] <= R[j]) ? L[i++] : R[j++];
    }
    
    // 处理剩余元素
    while (i < n1) arr[k++] = L[i++];
    while (j < n2) arr[k++] = R[j++];
    
    // 释放临时内存
    free(L);
    free(R);
}
```
- **临时数组**：使用动态内存分配创建临时数组 `L` 和 `R`，分别存储左右子数组。
- **双指针合并**：通过双指针 `i` 和 `j` 遍历两个子数组，将较小的元素依次放入原数组 `arr` 中。
- **内存释放**：合并完成后释放临时数组，避免内存泄漏。

### 2. 归并排序主函数 `mergeSort`
```c
void mergeSort(int arr[], int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2;  // 计算中点（避免整数溢出）
        
        // 递归排序左右子数组
        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);
        
        // 合并已排序的子数组
        merge(arr, left, mid, right);
    }
}
```
- **递归终止条件**：当子数组长度为1时（`left >= right`），停止递归。
- **中点计算**：使用 `left + (right - left) / 2` 代替 `(left + right) / 2`，避免 `left + right` 溢出。


## 四、如何运行代码
### 1. 环境要求
- C语言编译器（如GCC、Clang）

### 2. 编译与运行
```bash
# 使用GCC编译
gcc merge_sort.c -o merge_sort

# 运行程序
./merge_sort
```

### 3. 输出示例
```
给定的数组是 
12 11 13 5 6 7 

排序后的数组是 
5 6 7 11 12 13 
```


## 五、算法复杂度
| 复杂度   | 描述                     |
|----------|--------------------------|
| 时间复杂度 | O(n log n)（稳定排序）   |
| 空间复杂度 | O(n)（合并时需要临时数组）|


## 六、注意事项
1. **内存管理**：`merge` 函数中动态分配的临时数组需及时释放（已在代码中处理）。
2. **数组越界**：确保传入 `mergeSort` 的 `left` 和 `right` 参数在合法范围内（通常为 `0` 和 `n-1`）。
3. **大数处理**：若数组元素过多，递归深度可能导致栈溢出，可改用迭代实现或增大栈空间。


## 七、扩展建议
1. **优化临时数组**：预先分配固定大小的临时数组，避免重复申请/释放内存。
2. **小数组优化**：当子数组长度较小时（如小于16），改用插入排序提高效率。
3. **并行归并**：利用多线程并行处理子数组排序，适用于多核CPU场景。

