# 计数排序C语言实现

## 一、概述
计数排序（Counting Sort）是一种高效的线性时间排序算法，适用于数据范围较小的非负整数排序。本实现提供了标准的计数排序功能，具有稳定性和线性时间复杂度的特点。

## 二、代码结构
```c
// 计数排序函数
void countingSort(int arr[], int n, int maxValue);

// 打印数组函数
void printArray(int arr[], int n);
```

## 三、算法原理
计数排序的核心思想是利用数组下标来确定元素的正确位置，通过以下步骤实现排序：
1. **统计元素频率**：遍历待排序数组，统计每个元素出现的次数。
2. **计算前缀和**：将频率数组转换为前缀和数组，用于确定每个元素在输出数组中的位置。
3. **构建有序数组**：根据前缀和数组，将元素按顺序放入输出数组中，确保排序的稳定性。

## 四、编译与运行
### 1. 编译命令
```bash
gcc counting_sort.c -o counting_sort
```

### 2. 运行示例
```bash
./counting_sort
```

### 3. 输出结果
```
排序前的数组: 4 2 2 8 3 3 1 
排序后的数组: 1 2 2 3 3 4 8 
```

## 五、参数说明
| 参数      | 描述                                                                 |
|-----------|----------------------------------------------------------------------|
| `arr[]`   | 待排序的数组，要求元素为非负整数。                                   |
| `n`       | 数组的长度。                                                         |
| `maxValue`| 数组中的最大值，用于确定计数数组的大小。需确保所有元素不超过此值。   |

## 六、复杂度分析
| 维度       | 复杂度   | 说明                                                                 |
|------------|----------|----------------------------------------------------------------------|
| 时间复杂度 | O(n + k) | n为数组长度，k为数据范围（maxValue+1）。优于比较排序的O(n log n)。 |
| 空间复杂度 | O(n + k) | 需要额外的计数数组和输出数组。                                       |
| 稳定性     | 稳定     | 相同元素的相对顺序在排序后保持不变。                                 |

## 七、使用限制
1. **仅支持非负整数**：若数据包含负数，需先进行偏移转换。
2. **数据范围限制**：`maxValue` 不宜过大，否则会导致内存消耗显著增加。
3. **需提前知晓最大值**：调用函数时必须提供准确的 `maxValue`，否则可能导致数组越界。

## 八、扩展应用
### 1. 处理负数
```c
// 假设数组最小值为minValue
int minValue = -5;
int range = maxValue - minValue;

// 偏移转换为非负整数
for (int i = 0; i < n; i++) {
    arr[i] -= minValue;
}

// 执行计数排序
countingSort(arr, n, range);

// 恢复原始值
for (int i = 0; i < n; i++) {
    arr[i] += minValue;
}
```

### 2. 字符串排序（结合基数排序）
可按字符的ASCII值进行计数排序，实现字符串的字典序排序。

## 九、优化建议
1. **动态获取最大值**：在函数内部添加遍历逻辑，自动计算数组的最大值。
2. **减少内存分配**：对于固定数据范围的场景，可将计数数组设为静态数组。
3. **边界检查**：添加参数合法性检查，避免传入无效的 `maxValue`。

## 十、常见问题
### 1. 内存溢出
若 `maxValue` 过大，可能导致计数数组占用过多内存。建议在数据范围超过10^6时慎用。

### 2. 稳定性破坏
若在构建输出数组时采用正序遍历（而非倒序），会导致排序失去稳定性。

### 3. 负数处理错误
未进行偏移转换直接对负数排序会导致数组越界。需确保所有元素转换为非负整数后再排序。