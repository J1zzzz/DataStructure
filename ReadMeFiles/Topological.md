
# 拓扑排序实现文档（基于Kahn算法）

## 一、算法概述
拓扑排序（Topological Sorting）是对有向无环图（DAG）的顶点进行排序的算法，使得对于图中的每条有向边 `u→v`，顶点 `u` 在排序中始终出现在顶点 `v` 之前。该算法常用于任务调度、依赖分析、编译优化等场景。本实现基于 **Kahn算法**（入度统计法），通过队列迭代处理入度为0的节点，时间复杂度为 **O(V+E)**（V为顶点数，E为边数），适用于稀疏图。


## 二、功能特点
1. **邻接表存储**：使用邻接表表示图结构，节省内存，适合边数较少的稀疏图。
2. **入度统计**：通过维护每个节点的入度数组，高效识别可处理的节点。
3. **环检测**：自动检测图中是否存在环，若存在则无法完成拓扑排序。
4. **内存管理**：提供图内存释放函数，避免内存泄漏。


## 三、代码结构
```c
#include <stdio.h>
#include <stdlib.h>

#define MAX_VERTICES 100 // 最大顶点数

// 邻接表节点结构体
typedef struct Node { int vertex; struct Node* next; } Node;

// 图结构体（包含邻接表和入度数组）
typedef struct {
    Node* adj[MAX_VERTICES];  // 邻接表
    int inDegree[MAX_VERTICES]; // 入度数组
    int V;                    // 顶点数
} Graph;

// 核心函数声明
Graph* createGraph(int vertices);     // 创建图
void addEdge(Graph* graph, int u, int v); // 添加边
int topologicalSort(Graph* graph, int* order); // 拓扑排序
void freeGraph(Graph* graph);          // 释放图内存
```


## 四、核心函数解析
### 1. `createGraph(int vertices)`
- **功能**：初始化一个空图，分配邻接表和入度数组内存。
- **参数**：`vertices` 为图的顶点数。
- **返回值**：图结构体指针。

### 2. `addEdge(Graph* graph, int u, int v)`
- **功能**：向图中添加有向边 `u→v`。
- **参数**：
    - `graph`：图结构体指针。
    - `u`：起点，`v`：终点。
- **操作**：
    - 在邻接表中为 `u` 添加指向 `v` 的节点。
    - 增加 `v` 的入度（`inDegree[v]++`）。

### 3. `topologicalSort(Graph* graph, int* order)`
- **功能**：执行拓扑排序并存储结果。
- **参数**：
    - `graph`：图结构体指针。
    - `order`：用于存储排序结果的数组。
- **返回值**：`1` 表示排序成功，`0` 表示图中存在环。
- **算法流程**：
    1. **初始化队列**：将所有入度为0的节点入队。
    2. **迭代处理队列**：
        - 取出队首节点 `u`，加入排序结果。
        - 遍历 `u` 的所有邻接节点 `v`，将 `v` 的入度减1。若入度变为0，则将 `v` 入队。
    3. **环检测**：若排序结果的节点数不等于总顶点数，说明存在环。

### 4. `freeGraph(Graph* graph)`
- **功能**：释放邻接表和图结构体的内存，避免内存泄漏。


## 五、使用示例
### 输入图结构（示例）
```c
Graph* graph = createGraph(6); // 6个顶点
addEdge(graph, 5, 2);  // 5→2
addEdge(graph, 5, 0);  // 5→0
addEdge(graph, 4, 0);  // 4→0
addEdge(graph, 4, 1);  // 4→1
addEdge(graph, 2, 3);  // 2→3
addEdge(graph, 3, 1);  // 3→1
```
该图表示的依赖关系如下：
- 节点5依赖于2和0
- 节点4依赖于0和1
- 节点2依赖于3
- 节点3依赖于1

### 输出结果
```
拓扑排序结果：4 5 2 3 0 1 （可能存在多种合法排序）
```


## 六、注意事项
1. **图类型限制**：仅适用于有向无环图（DAG），若图中存在环，排序将失败并提示。
2. **顶点编号**：顶点需使用 `0~MAX_VERTICES-1` 的连续整数编号，建议提前规划编号规则。
3. **内存管理**：使用完图后需调用 `freeGraph` 释放内存，避免程序内存泄漏。
4. **大规模图**：若顶点数超过 `MAX_VERTICES`，需修改宏定义并重新编译。


## 七、扩展应用
1. **任务调度**：例如课程先修关系、编译流程中的模块依赖。
2. **依赖分析**：软件包管理（如Linux系统的包依赖解析）。
3. **数据处理流程**：ETL（抽取-转换-加载）任务的顺序执行。
4. **网络路由**：有向无环网络中的路径规划（需结合其他算法）。


## 八、常见问题
- **Q：如何处理非连续顶点编号？**  
  A：建议对顶点重新编号（如映射为0~n-1），或扩展邻接表支持任意编号（需改用哈希表存储）。

- **Q：拓扑排序结果唯一吗？**  
  A：不唯一。当图中存在多个入度为0的节点时，处理顺序不同会导致结果不同（如示例中4和5可互换顺序）。

- **Q：能否处理无向图？**  
  A：不能。拓扑排序仅适用于有向图，无向图需先转换为有向图（如添加方向）或检测是否为树/森林。