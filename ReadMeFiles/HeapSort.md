# 堆排序（Heap Sort）C语言实现

本项目提供了堆排序算法的C语言实现，包含完整的代码和测试示例。堆排序是一种高效的排序算法，基于二叉堆数据结构，具有稳定的时间复杂度O(n log n)，适用于处理大规模数据。

## 算法原理

堆排序利用二叉堆的特性进行排序，具体分为两个阶段：

1. **构建最大堆**：将待排序数组转换为最大堆结构，每个节点的值都大于或等于其子节点的值。
2. **排序过程**：
    - 将堆顶元素（最大值）与当前未排序部分的最后一个元素交换
    - 减少堆的大小，重新调整剩余元素为最大堆
    - 重复上述步骤，直到整个数组有序

## 代码结构

项目包含以下核心组件：

1. **swap函数**：交换两个整数的值
2. **heapify函数**：递归调整堆，确保以指定节点为根的子树满足最大堆性质
3. **heapSort函数**：堆排序主函数，包含构建最大堆和排序过程
4. **printArray函数**：辅助函数，用于打印数组内容
5. **main函数**：程序入口，演示堆排序的使用方法

## 使用方法

1. 确保你的系统安装了C语言编译器（如GCC）
2. 将代码保存为`.c`文件，例如`heap_sort.c`
3. 编译代码：`gcc heap_sort.c -o heap_sort`
4. 运行程序：`./heap_sort`

程序将输出排序前后的数组内容，展示堆排序的效果。

## 示例代码

```c
#include <stdio.h>

// 交换两个元素
void swap(int *a, int *b);

// 调整堆
void heapify(int arr[], int n, int i);

// 堆排序主函数
void heapSort(int arr[], int n);

// 打印数组
void printArray(int arr[], int n);

int main() {
    int arr[] = {12, 11, 13, 5, 6, 7};
    int n = sizeof(arr) / sizeof(arr[0]);

    printf("排序前的数组：\n");
    printArray(arr, n);

    heapSort(arr, n);

    printf("排序后的数组：\n");
    printArray(arr, n);

    return 0;
}
```

## 复杂度分析

- **时间复杂度**：O(n log n)，无论是最好、最坏还是平均情况
- **空间复杂度**：O(1)，只需要常数级的额外空间
- **稳定性**：不稳定排序，可能改变相等元素的相对顺序

## 注意事项

1. 堆排序是一种原地排序算法，不需要额外的存储空间
2. 由于使用了递归的heapify函数，在极端情况下可能导致栈溢出（对于超大规模数据）
3. 对于小规模数据，插入排序等简单算法可能更高效

## 应用场景

堆排序适用于以下场景：

- 需要稳定时间复杂度的排序任务
- 处理大规模数据
- 优先队列的实现
- 需要原地排序的场合

## 算法优势

- 时间复杂度稳定，不受输入数据分布影响
- 原地排序，不需要额外空间
- 适用于实时系统，因为每次操作的时间复杂度可控