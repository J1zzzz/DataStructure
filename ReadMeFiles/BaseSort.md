
# 基数排序C语言实现

## 一、概述
基数排序（Radix Sort）是一种非比较排序算法，通过将数字按位分组排序（从最低位到最高位或最高位到最低位），实现线性时间复杂度的排序。本仓库提供两种基数排序实现：**LSD（最低位优先）**和**MSD（最高位优先）**，适用于不同场景的整数排序需求。


## 二、目录结构
```
radix_sort/
├── radix_sort_lsd.c   # LSD基数排序实现
├── radix_sort_msd.c   # MSD基数排序实现
└── README.md          # 文档说明
```


## 三、LSD基数排序（最低位优先）
### 3.1 原理
从最低位（个位）开始，逐位对数字进行计数排序，保持稳定性，直到最高位处理完毕。适用于非负整数排序。

### 3.2 核心函数
| 函数名         | 功能描述                             |
|----------------|--------------------------------------|
| `getMax`       | 获取数组中的最大值                   |
| `countSort`    | 基于当前位（exp）进行计数排序        |
| `radixSortLSD` | LSD基数排序主函数                    |

### 3.3 代码示例
```c
int arr[] = {170, 45, 75, 90, 802, 24, 2, 66};
int n = sizeof(arr) / sizeof(arr[0]);
radixSortLSD(arr, n);
```

### 3.4 执行流程
1. **获取最大值**：确定数组中最大数的位数。
2. **逐位排序**：从个位（`exp=1`）开始，每次对当前位进行计数排序，直到最高位。
3. **稳定性保证**：计数排序过程中保持相同元素的相对顺序。


## 四、MSD基数排序（最高位优先）
### 4.1 原理
从最高位开始，将元素按当前位的值分配到10个“桶”中，递归对每个非空桶进行排序，直至所有位处理完毕。适用于字符串或字典序排序。

### 4.2 核心函数
| 函数名           | 功能描述                             |
|------------------|--------------------------------------|
| `getDigit`       | 获取数字第d位的值（从最高位开始）   |
| `radixSortMSD`   | 递归实现MSD基数排序                 |
| `radixSortMSDWrapper` | 主函数，初始化递归参数          |

### 4.3 代码示例
```c
int arr[] = {170, 45, 75, 90, 802, 24, 2, 66};
int n = sizeof(arr) / sizeof(arr[0]);
radixSortMSDWrapper(arr, n);
```

### 4.4 执行流程
1. **确定最大位数**：计算数组中最大值的位数。
2. **分配桶**：按最高位将元素分配到0-9号桶中。
3. **递归排序**：对每个非空桶递归处理下一位，直至所有位排序完成。


## 五、编译与运行
### 5.1 编译命令
```bash
# 编译LSD版本
gcc radix_sort_lsd.c -o radix_lsd

# 编译MSD版本
gcc radix_sort_msd.c -o radix_msd
```

### 5.2 运行示例
```bash
# 运行LSD排序
./radix_lsd
输出：
排序前的数组: 
170 45 75 90 802 24 2 66 

排序后的数组: 
2 24 45 66 75 90 170 802 

# 运行MSD排序
./radix_msd
输出同上
```


## 六、算法复杂度
| 类型     | 时间复杂度 | 空间复杂度 | 稳定性 | 适用场景               |
|----------|------------|------------|--------|------------------------|
| LSD基数排序 | O(d(n+k))  | O(n+k)     | 稳定   | 非负整数，位数较少     |
| MSD基数排序 | O(d(n+k))  | O(n+k)     | 稳定   | 字符串，字典序排序     |

- `d`：最大位数（如`802`的位数为3）
- `n`：数组长度
- `k`：基数（默认10，即0-9的桶数）


## 七、注意事项
### 7.1 负数处理
当前实现仅支持非负整数。若需排序负数，可通过以下步骤处理：
1. 找到最小值`min`，将所有元素加上`-min`转为非负数。
2. 排序后，再减去`-min`恢复原数值。

### 7.2 递归深度限制（MSD）
MSD使用递归实现，当数组规模较大时可能导致栈溢出。可改用迭代或增大栈空间（如Linux下使用`ulimit -s unlimited`）。

### 7.3 基数调整
若数据分布特殊（如二进制数据），可将基数`k`改为2、16等，减少排序次数。


## 八、扩展建议
1. **优化临时空间**：预分配全局临时数组，避免重复申请/释放内存。
2. **混合排序**：当桶内元素较少时（如小于10个），改用插入排序提高效率。
3. **字符串排序**：MSD可扩展为字符串排序，按字符ASCII值分配桶。


