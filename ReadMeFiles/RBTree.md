下面是添加了红黑树插入和删除情形示意图的README文档，用SVG图像直观展示各种调整情况：


# 红黑树 C语言实现

## 一、项目简介
本项目提供了红黑树（Red-Black Tree）的C语言实现，包含节点插入、删除、中序遍历等核心操作。红黑树是一种自平衡二叉搜索树，通过颜色标记和旋转操作确保树的平衡，适用于需要高效查找、插入和删除的场景。


## 二、红黑树特性
1. **节点颜色**：每个节点非红即黑。
2. **根节点**：根节点始终为黑色。
3. **叶子节点**：所有叶子节点（哨兵节点 `NIL`）为黑色。
4. **红色节点限制**：红色节点的子节点必须为黑色（避免连续红色节点）。
5. **黑色高度平衡**：从任意节点到其所有后代叶子节点的路径上，黑色节点数量相同。


## 三、代码结构说明
### 1. 数据结构定义
```c
// 颜色枚举
typedef enum { RED, BLACK } Color;

// 节点结构
typedef struct RBNode {
    int key;               // 键值
    Color color;           // 颜色
    struct RBNode *left;   // 左子节点
    struct RBNode *right;  // 右子节点
    struct RBNode *parent; // 父节点
} RBNode;

// 红黑树结构（包含根节点和哨兵节点）
typedef struct RBTree {
    RBNode *root; // 根节点
    RBNode *NIL;  // 哨兵节点（代替NULL，简化边界处理）
} RBTree;
```

### 2. 核心函数
#### （1）初始化与节点操作
- `RBTree* createTree()`：创建红黑树，初始化根节点和哨兵节点。
- `RBNode* newNode(RBTree *tree, int key, Color color)`：创建新节点，指定键值和颜色。

#### （2）旋转操作（维持平衡）
- `void leftRotate(RBTree *tree, RBNode *x)`：左旋节点 `x`。
- `void rightRotate(RBTree *tree, RBNode *y)`：右旋节点 `y`。

#### （3）插入操作
- `void insert(RBTree *tree, int key)`：插入键值，自动调用 `insertFixup` 修复红黑树特性。
- `void insertFixup(RBTree *tree, RBNode *z)`：插入后通过颜色调整和旋转修复平衡。

#### （4）删除操作
- `void deleteNode(RBTree *tree, int key)`：删除指定键值的节点，自动调用 `deleteFixup` 修复平衡。
- `void deleteFixup(RBTree *tree, RBNode *x)`：删除后通过颜色调整和旋转修复平衡。

#### （5）辅助函数
- `void inorder(RBTree *tree, RBNode *node)`：中序遍历树（用于验证结构正确性）。



以下是更新后的 README 文档，包含红黑树 **插入和删除操作的 ASCII 艺术示意图**，直接嵌入文本中便于查看：


# 红黑树 C语言实现

## 四、红黑树调整情形 ASCII 艺术示意图

### 1. 插入操作调整情形
#### 情形 1：父节点为黑色（无需调整）
```
插入前/后：
      B(黑)
     /   \
   P(黑)  ...
  /
Z(红)
```
- **说明**：插入红色节点 `Z`，父节点 `P` 为黑色，直接插入，无需旋转或变色。

#### 情形 2：父节点为红色，叔节点为红色（颜色调整）
```
插入前：
      G(红)         插入后：
     /   \               G(黑)
   P(红)  U(红)         /   \
  /                   P(黑) U(黑)
 Z(红)                 /
                      Z(红)
```
- **操作**：
    1. 父节点 `P` 和叔节点 `U` 染黑；
    2. 祖父节点 `G` 染红；
    3. 递归处理祖父节点 `G`。

#### 情形 3：父节点为红色，叔节点为黑色（左左型，右旋祖父）
```
插入前（左左型）：       插入后（右旋 G）：
        G(红)                P(黑)
       /  \                 /   \
     P(红) R(黑)           G(红)  R(黑)
    /                        /
  Z(红)                     Z(红)
```
- **操作**：
    1. 对祖父节点 `G` 右旋；
    2. 父节点 `P` 染黑，祖父节点 `G` 染红。

#### 情形 4：父节点为红色，叔节点为黑色（左右型，先左旋父再右旋祖父）
```
插入前（左右型）：       中间步骤（左旋 P）：       最终（右旋 G）：
        G(红)                G(红)                  Z(黑)
       /  \                 /  \                  /   \
     P(红) R(黑)           Z(红) P(红)            G(红)  P(红)
      \                      /                      \   /
      Z(红)                Z(左) P(右)              R(黑)
```
- **操作**：
    1. 对父节点 `P` 左旋，转为情形 3；
    2. 对祖父节点 `G` 右旋，调整颜色。


### 2. 删除操作调整情形
#### 情形 1：兄弟节点为红色（旋转+变色）
```
删除前（左子树删除后，兄弟 S 为红）：
      P(黑)              删除后（左旋 P，S 染黑）：
     /   \                   S(黑)
   X(黑)  S(红)             /   \
      \                   P(红) SR(...)
       ...                /
                      X(黑)
```
- **操作**：
    1. 父节点 `P` 染红，兄弟 `S` 染黑；
    2. 对父节点 `P` 左旋，转为其他情形处理。

#### 情形 2：兄弟节点为黑色，子节点均为黑色（向上递归）
```
删除前（兄弟 S 为黑，子节点全黑）：
      P(黑)              删除后（S 染红，X 指向 P）：
     /   \                   P(黑)
   X(黑)  S(黑)             /   \
          / \                 X(黑) S(红)
        SL(黑) SR(黑)
```
- **操作**：
    1. 兄弟节点 `S` 染红；
    2. 递归处理父节点 `P`。

#### 情形 3：兄弟节点为黑色，左子节点为红色（右旋兄弟）
```
删除前（S 左子红，右子黑）：     中间步骤（右旋 S）：
      P(黑)                      P(黑)
     /   \                       /   \
   X(黑)  S(黑)                 X(黑) SL(黑)
          /   \                     / \
        SL(红) SR(黑)               S(红) SR(黑)
```
- **操作**：
    1. 兄弟 `S` 染红，左子 `SL` 染黑；
    2. 对兄弟 `S` 右旋，转为情形 4。

#### 情形 4：兄弟节点为黑色，右子节点为红色（左旋父节点）
```
删除前（S 右子 SR 为红）：       删除后（左旋 P，调整颜色）：
      P(黑)                      S(黑)
     /   \                       /   \
   X(黑)  S(黑)                 P(黑) SR(黑)
          /   \                 /
        SL(黑) SR(红)           X(黑)
```
- **操作**：
    1. 兄弟 `S` 颜色设为父节点 `P` 的颜色；
    2. 父节点 `P` 和兄弟右子 `SR` 染黑；
    3. 对父节点 `P` 左旋。


## 五、使用示例（略）
（其他章节内容不变，图示已整合到「四、红黑树调整情形 ASCII 艺术示意图」章节）


### 图示说明：
- **符号约定**：
    - `B(黑)`/`R(红)`：节点颜色；
    - `P`：父节点，`G`：祖父节点，`U`：叔节点，`S`：兄弟节点；
    - `->`：旋转方向（左旋/右旋）。
- **层次结构**：用缩进表示树的层级，`/ \` 表示左右子节点。

通过 ASCII 示意图可直观看到红黑树调整的核心逻辑，配合代码注释能更清晰理解旋转和颜色变换的实现细节。


## 五、使用示例
### 1. 编译与运行
```bash
gcc rbtree.c -o rbtree
./rbtree
```

### 2. 测试代码（`main` 函数）
```c
int main() {
    RBTree *tree = createTree();

    // 插入测试数据
    insert(tree, 5);
    insert(tree, 3);
    insert(tree, 7);
    insert(tree, 2);
    insert(tree, 4);
    insert(tree, 6);
    insert(tree, 8);

    printf("插入后的中序遍历：\n");
    inorder(tree, tree->root); // 输出：2 3 4 5 6 7 8
    printf("\n");

    // 删除节点 3
    deleteNode(tree, 3);
    printf("删除3后的中序遍历：\n");
    inorder(tree, tree->root); // 输出：2 4 5 6 7 8
    printf("\n");

    return 0;
}
```


## 六、注意事项
1. **哨兵节点 `NIL`**：  
   代码中使用哨兵节点 `NIL` 代替传统的 `NULL`，避免频繁判断空指针，简化边界条件处理。所有叶子节点（原生 `NULL`）均指向 `NIL`。

2. **内存管理**：
    - 创建树时需调用 `createTree()`，结束后需手动释放所有节点内存（示例中未包含完整释放逻辑，实际使用时需补充）。
    - 删除节点后会自动释放被删除节点的内存，但根节点和哨兵节点需手动释放。

3. **扩展功能**：
    - 可根据需求添加查找（`search`）、获取最小值/最大值（`min/max`）等功能。
    - 若需存储复杂数据，可修改节点结构，增加数据字段。

4. **平衡特性**：  
   插入和删除操作的时间复杂度均为 **O(log n)**，适用于高频动态数据操作场景。


## 七、常见问题
- **为什么使用红黑树而非AVL树？**  
  红黑树的平衡条件更宽松（AVL树要求左右子树高度差≤1），插入和删除时的旋转次数更少，实际性能更优，适合频繁修改的场景。

- **如何验证红黑树的平衡性？**  
  可通过中序遍历验证节点有序性，并手动检查红黑树特性（如黑色高度一致、无连续红色节点等）。


## 八、贡献与反馈
推荐图示工具：
- [Red-Black Tree Visualization](https://www.cs.usfca.edu/~galles/visualization/RedBlack.html)：动态演示插入 / 删除过程，可截图保存。

