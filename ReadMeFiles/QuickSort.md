以下是快速排序算法实现的 README 文档：


# 快速排序算法实现

## 概述
本项目实现了经典的快速排序算法，通过分治法策略将数组高效排序。代码采用递归方式实现，并使用双指针法进行分区操作，确保算法的时间复杂度为 O(n log n)（平均情况）。

## 算法原理
快速排序的核心思想是：
1. **分治法**：将问题分解为更小的子问题
2. **分区操作**：选择基准元素，将数组分为两部分
    - 左侧元素均小于等于基准值
    - 右侧元素均大于等于基准值
3. **递归排序**：分别对左右两部分递归应用快速排序

## 代码结构
```c
// 分区函数：选择基准元素并将数组分为两部分
int partition(int *arr, int low, int high);

// 快速排序主函数：递归实现分治策略
void quickSort(int arr[], int low, int high);

// 主函数：测试排序功能
int main();
```

## 核心实现细节
1. **分区策略**：
    - 选择数组第一个元素作为基准值
    - 使用双指针法从两端向中间扫描
    - 确保基准值左侧元素≤基准值，右侧元素≥基准值

2. **递归处理**：
    - 递归处理基准值左侧子数组
    - 递归处理基准值右侧子数组

3. **终止条件**：
    - 当子数组长度≤1时终止递归

## 复杂度分析
- **时间复杂度**：平均 O(n log n)，最坏 O(n²)
- **空间复杂度**：O(log n)（递归栈空间）
- **稳定性**：不稳定排序

## 使用示例
```c
int main() {
    int arr[10] = {22,11,1,67,56,32,16,98,20,4};
    quickSort(arr, 0, 9);  // 调用快速排序函数
    // 输出结果：1 4 11 16 20 22 32 56 67 98
}
```

## 优化建议
1. **基准值选择**：当前实现选择第一个元素作为基准，可改进为随机选择或三数取中法
2. **小规模数组处理**：对于小规模子数组可使用插入排序提高效率
3. **非递归实现**：使用栈结构实现非递归版本，减少栈溢出风险

## 应用场景
快速排序适用于大多数需要高效排序的场景，尤其适合：
- 数据量大且分布随机的数组
- 对内存使用有严格要求的系统
- 平均性能要求较高的应用

## 注意事项
- 快速排序在最坏情况下（已排序数组）性能退化为 O(n²)
- 递归深度可能达到 O(n)，对极大型数组需注意栈溢出问题